#if defined(__GNUC__) || defined(__GLIBC__)
#	ifndef _GNU_SOURCE
#		define _GNU_SOURCE
#	endif
#endif /* _GNU_SOURCE */

#include "../lib/librgrep.h"
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <dirent.h>

#define MAX_PATH_LEN 4096

long g_child_max;
unsigned int g_child_tot;
unsigned int g_fuldirlen;
pid_t pid = 1;

static void find(const char *RESTRICT dir, const size_t dlen)
{
	DIR *RESTRICT dp = opendir(dir);
	if (unlikely(!dp))
		return;
	struct dirent *RESTRICT ep;
	char fulpath[MAX_PATH_LEN];
	while ((ep = readdir(dp))) {
#if DEBUG
		printf("d->name: %s\n", ep->d_name);
#endif /* DEBUG */

/* skip . , .., .git, .vscode */
#define IF_EXCLUDED_DO(filename, action)       \
	if (filename[0] == '.')                \
		switch (filename[1]) {         \
		case '.':                      \
		case '\0':                     \
			action;                \
			break;                 \
		case 'g':                      \
			if (filename[2] == 'i' \
			&& filename[3] == 't') \
				action;        \
			break;                 \
		case 'v':                      \
			if (filename[2] == 's' \
			&& filename[3] == 'c'  \
			&& filename[4] == 'o'  \
			&& filename[5] == 'd'  \
			&& filename[6] == 'e') \
				action;        \
			break;                 \
		}

#define DO_DIR                                                                    \
	IF_EXCLUDED_DO(ep->d_name, continue)                                      \
	if (pid > 0) {                                                            \
		if (g_child_tot == g_child_max) {                                 \
			wait(NULL);                                               \
			--g_child_tot;                                            \
		}                                                                 \
		pid = fork();                                                     \
	}                                                                         \
	switch (pid) {                                                            \
	case 0:                                                                   \
		fwrite(fulpath, 1, dlen, stdout);                                 \
		find(fulpath, appendp(fulpath, dir, dlen, ep->d_name) - fulpath); \
		break;                                                            \
	default:                                                                  \
		++g_child_tot;                                                    \
	case -1:;                                                                 \
	}

#ifdef _DIRENT_HAVE_D_TYPE
		switch (ep->d_type) {
		case DT_REG:
			fwrite(fulpath, 1, dlen, stdout);
			putchar('/');
			puts(ep->d_name);
			break;
		case DT_DIR:
			DO_DIR;
			break;
		}
#else
		if (unlikely(stat(dir, &g_st)))
			return;
		if (S_ISREG(g_st.st_mode))
			fwrite(fulpath, 1, dlen, stdout);
			putchar('/');
			puts(ep->d_name);
		else if (S_ISDIR(g_st.st_mode))
			DO_DIR;
#endif /* _DIRENT_HAVE_D_TYPE */

#if DEBUG
		printf("entries: %s\n", ep->d_name);
#endif /* DEBUG */
	}
	closedir(dp);
}

static void get_dir(char *buf)
{
	getcwd(buf, MAX_PATH_LEN);
	g_fuldirlen = strlen(buf);
}

int main()
{
	g_child_max = sysconf(_SC_NPROCESSORS_CONF);
	char cwd[MAX_PATH_LEN];
	get_dir(cwd);
	find(cwd, g_fuldirlen);
}
